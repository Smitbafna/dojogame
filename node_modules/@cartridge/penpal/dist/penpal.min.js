var Penpal=function(){"use strict";var e;(function(e){e["Call"]="call";e["Reply"]="reply";e["Syn"]="syn";e["SynAck"]="synAck";e["Ack"]="ack"})(e||(e={}));var n;(function(e){e["Fulfilled"]="fulfilled";e["Rejected"]="rejected"})(n||(n={}));var t;(function(e){e["ConnectionDestroyed"]="ConnectionDestroyed";e["ConnectionTimeout"]="ConnectionTimeout";e["NoIframeSrc"]="NoIframeSrc"})(t||(t={}));var r;(function(e){e["DataCloneError"]="DataCloneError"})(r||(r={}));var o;(function(e){e["Message"]="message"})(o||(o={}));var s=(e,n)=>{const t=[];let r=false;return{destroy(o){if(!r){r=true;n(`${e}: Destroying connection`);t.forEach(e=>{e(o)})}},onDestroy(e){r?e():t.push(e)}}};var i=e=>function(){if(e){for(var n=arguments.length,t=new Array(n),r=0;r<n;r++){t[r]=arguments[r]}console.log("[Penpal]",...t)}};const c={"http:":"80","https:":"443"};const a=/^(https?:)?\/\/([^/:]+)?(:(\d+))?/;const d=["file:","data:"];var l=e=>{if(e&&d.find(n=>e.startsWith(n))){return"null"}const n=document.location;const t=a.exec(e);let r;let o;let s;if(t){r=t[1]?t[1]:n.protocol;o=t[2];s=t[4]}else{r=n.protocol;o=n.hostname;s=n.port}const i=s&&s!==c[r]?`:${s}`:"";return`${r}//${o}${i}`};const u=e=>{let{name:n,message:t,stack:r}=e;return{name:n,message:t,stack:r}};const f=e=>{const n=new Error;Object.keys(e).forEach(t=>n[t]=e[t]);return n};var g=(t,s,i)=>{const{localName:c,local:a,remote:d,originForSending:l,originForReceiving:f}=t;let g=false;const m=t=>{if(t.source!==d||t.data.penpal!==e.Call){return}if(f!=="*"&&t.origin!==f){i(`${c} received message from origin ${t.origin} which did not match expected origin ${f}`);return}const o=t.data;const{methodName:a,args:m,id:p}=o;i(`${c}: Received ${a}() call`);const h=t=>o=>{i(`${c}: Sending ${a}() reply`);if(g){i(`${c}: Unable to send ${a}() reply due to destroyed connection`);return}const s={penpal:e.Reply,id:p,resolution:t,returnValue:o};if(t===n.Rejected&&o instanceof Error){s.returnValue=u(o);s.returnValueIsError=true}try{d.postMessage(s,l)}catch(t){if(t.name===r.DataCloneError){const r={penpal:e.Reply,id:p,resolution:n.Rejected,returnValue:u(t),returnValueIsError:true};d.postMessage(r,l)}throw t}};new Promise(e=>e(s[a].call(s,t.origin).apply(s,m))).then(h(n.Fulfilled),h(n.Rejected))};a.addEventListener(o.Message,m);return()=>{g=true;a.removeEventListener(o.Message,m)}};let m=0;var p=()=>++m;const h=".";const v=e=>e?e.split(h):[];const y=e=>e.join(h);const w=(e,n)=>{const t=v(n||"");t.push(e);return y(t)};const $=(e,n,t)=>{const r=v(n);r.reduce((e,n,o)=>{if(typeof e[n]==="undefined"){e[n]={}}if(o===r.length-1){e[n]=t}return e[n]},e);return e};const C=(e,n)=>{const t={};Object.keys(e).forEach(r=>{const o=e[r];const s=w(r,n);if(typeof o==="object"){Object.assign(t,C(o,s))}if(typeof o==="function"){t[s]=o}});return t};const E=e=>{const n={};for(const t in e){$(n,t,e[t])}return n};var k=(r,s,i,c,a)=>{const{localName:d,local:l,remote:u,originForSending:g,originForReceiving:m}=s;let h=false;a(`${d}: Connecting call sender`);const v=r=>function(){for(var s=arguments.length,i=new Array(s),v=0;v<s;v++){i[v]=arguments[v]}a(`${d}: Sending ${r}() call`);let y;try{if(u.closed){y=true}}catch(e){y=true}if(y){c()}if(h){const e=new Error(`Unable to send ${r}() call due `+`to destroyed connection`);e.code=t.ConnectionDestroyed;throw e}return new Promise((t,s)=>{const c=p();const h=i=>{if(i.source!==u||i.data.penpal!==e.Reply||i.data.id!==c){return}if(m!=="*"&&i.origin!==m){a(`${d} received message from origin ${i.origin} which did not match expected origin ${m}`);return}const g=i.data;a(`${d}: Received ${r}() reply`);l.removeEventListener(o.Message,h);let p=g.returnValue;if(g.returnValueIsError){p=f(p)}(g.resolution===n.Fulfilled?t:s)(p)};l.addEventListener(o.Message,h);const v={penpal:e.Call,id:c,methodName:r,args:i};u.postMessage(v,g)})};const y=i.reduce((e,n)=>{e[n]=v(n);return e},{});Object.assign(r,E(y));return()=>{h=true}};var R=(e,n,t,r,o)=>{const{destroy:s,onDestroy:i}=r;let c;let a;const d={};return r=>{if(n!=="*"&&r.origin!==n){o(`Parent: Handshake - Received ACK message from origin ${r.origin} which did not match expected origin ${n}`);return}o("Parent: Handshake - Received ACK");const l={localName:"Parent",local:window,remote:r.source,originForSending:t,originForReceiving:n};if(c){c()}c=g(l,e,o);i(c);if(a){a.forEach(e=>{delete d[e]})}a=r.data.methodNames;const u=k(d,l,a,s,o);i(u);return d}};var S=(n,t,r,o)=>s=>{if(!s.source){return}if(r!=="*"&&s.origin!==r){n(`Parent: Handshake - Received SYN message from origin ${s.origin} which did not match expected origin ${r}`);return}n("Parent: Handshake - Received SYN, responding with SYN-ACK");const i={penpal:e.SynAck,methodNames:Object.keys(t)};s.source.postMessage(i,o)};const N=6e4;var A=(e,n)=>{const{destroy:t,onDestroy:r}=n;const o=setInterval(()=>{if(!e.isConnected){clearInterval(o);t()}},N);r(()=>{clearInterval(o)})};var M=(e,n)=>{let r;if(e!==undefined){r=window.setTimeout(()=>{const r=new Error(`Connection timed out after ${e}ms`);r.code=t.ConnectionTimeout;n(r)},e)}return()=>{clearTimeout(r)}};var P=e=>{if(!e.src&&!e.srcdoc){const e=new Error("Iframe must have src or srcdoc property defined.");e.code=t.NoIframeSrc;throw e}};var j=n=>{let{iframe:t,methods:r={},childOrigin:c,timeout:a,debug:d=false}=n;const u=i(d);const f=s("Parent",u);const{onDestroy:g,destroy:m}=f;if(!c){P(t);c=l(t.src)}const p=c==="null"?"*":c;const h=C(r);const v=S(u,h,c,p);const y=R(h,c,p,f,u);const w=new Promise((n,r)=>{const s=M(a,m);const i=r=>{if(r.source!==t.contentWindow||!r.data){return}if(r.data.penpal===e.Syn){v(r);return}if(r.data.penpal===e.Ack){const e=y(r);if(e){s();n(e)}return}};window.addEventListener(o.Message,i);u("Parent: Awaiting handshake");A(t,f);g(e=>{window.removeEventListener(o.Message,i);if(e){r(e)}})});return{promise:w,destroy(){m()}}};var D=(n,t,r,o)=>{const{destroy:s,onDestroy:i}=r;return r=>{let c=n instanceof RegExp?n.test(r.origin):n==="*"||n===r.origin;if(!c){o(`Child: Handshake - Received SYN-ACK from origin ${r.origin} which did not match expected origin ${n}`);return}o("Child: Handshake - Received SYN-ACK, responding with ACK");const a=r.origin==="null"?"*":r.origin;const d={penpal:e.Ack,methodNames:Object.keys(t)};window.parent.postMessage(d,a);const l={localName:"Child",local:window,remote:window.parent,originForSending:a,originForReceiving:r.origin};const u=g(l,t,o);i(u);const f={};const m=k(f,l,r.data.methodNames,s,o);i(m);return f}};const b=()=>{try{clearTimeout()}catch(e){return false}return true};var F=function(){let n=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{parentOrigin:t="*",methods:r={},timeout:c,debug:a=false}=n;const d=i(a);const l=s("Child",d);const{destroy:u,onDestroy:f}=l;const g=C(r);const m=D(t,g,l,d);const p=()=>{d("Child: Handshake - Sending SYN");const n={penpal:e.Syn};const r=t instanceof RegExp?"*":t;window.parent.postMessage(n,r)};const h=new Promise((n,t)=>{const r=M(c,u);const s=t=>{if(!b()){return}if(t.source!==parent||!t.data){return}if(t.data.penpal===e.SynAck){const e=m(t);if(e){window.removeEventListener(o.Message,s);r();n(e)}}};window.addEventListener(o.Message,s);p();f(e=>{window.removeEventListener(o.Message,s);if(e){t(e)}})});return{promise:h,destroy(){u()}}};var I={connectToChild:j,connectToParent:F,ErrorCode:t};return I}();