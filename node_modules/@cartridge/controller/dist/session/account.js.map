{"version":3,"sources":["../../src/session/account.ts","../../src/utils.ts","../../src/errors.ts","../../src/types.ts"],"sourcesContent":["import { Policy } from \"@cartridge/account-wasm\";\nimport { CartridgeSessionAccount } from \"@cartridge/account-wasm/session\";\nimport { Call, InvokeFunctionResponse, WalletAccount } from \"starknet\";\n\nimport { normalizeCalls } from \"../utils\";\nimport BaseProvider from \"../provider\";\n\nexport * from \"../errors\";\nexport * from \"../types\";\n\nexport default class SessionAccount extends WalletAccount {\n  public controller: CartridgeSessionAccount;\n\n  constructor(\n    provider: BaseProvider,\n    {\n      rpcUrl,\n      privateKey,\n      address,\n      ownerGuid,\n      chainId,\n      expiresAt,\n      policies,\n    }: {\n      rpcUrl: string;\n      privateKey: string;\n      address: string;\n      ownerGuid: string;\n      chainId: string;\n      expiresAt: number;\n      policies: Policy[];\n    },\n  ) {\n    super({ nodeUrl: rpcUrl }, provider);\n\n    this.controller = CartridgeSessionAccount.new_as_registered(\n      rpcUrl,\n      privateKey,\n      address,\n      ownerGuid,\n      chainId,\n      {\n        expiresAt,\n        policies,\n      },\n    );\n  }\n\n  /**\n   * Invoke execute function in account contract\n   *\n   * @param calls the invocation object or an array of them, containing:\n   * - contractAddress - the address of the contract\n   * - entrypoint - the entrypoint of the contract\n   * - calldata - (defaults to []) the calldata\n   * - signature - (defaults to []) the signature\n   * @param abis (optional) the abi of the contract for better displaying\n   *\n   * @returns response from addTransaction\n   */\n  async execute(calls: Call | Call[]): Promise<InvokeFunctionResponse> {\n    return this.controller.execute(normalizeCalls(calls));\n  }\n}\n","import {\n  addAddressPadding,\n  Call,\n  CallData,\n  getChecksumAddress,\n  hash,\n  typedData,\n  TypedDataRevision,\n} from \"starknet\";\nimport wasm from \"@cartridge/account-wasm/controller\";\nimport { Policies, SessionPolicies } from \"@cartridge/presets\";\n\n// Whitelist of allowed property names to prevent prototype pollution\nconst ALLOWED_PROPERTIES = new Set([\n  \"contracts\",\n  \"messages\",\n  \"target\",\n  \"method\",\n  \"name\",\n  \"description\",\n  \"types\",\n  \"domain\",\n  \"primaryType\",\n]);\n\nfunction validatePropertyName(prop: string): void {\n  if (!ALLOWED_PROPERTIES.has(prop)) {\n    throw new Error(`Invalid property name: ${prop}`);\n  }\n}\n\nfunction safeObjectAccess<T>(obj: any, prop: string): T {\n  validatePropertyName(prop);\n  return obj[prop];\n}\n\nexport function normalizeCalls(calls: Call | Call[]) {\n  return toArray(calls).map((call) => {\n    return {\n      entrypoint: call.entrypoint,\n      contractAddress: addAddressPadding(call.contractAddress),\n      calldata: CallData.toHex(call.calldata),\n    };\n  });\n}\n\nexport function toSessionPolicies(policies: Policies): SessionPolicies {\n  return Array.isArray(policies)\n    ? policies.reduce<SessionPolicies>(\n        (prev, p) => {\n          if (safeObjectAccess<string>(p, \"target\")) {\n            const target = getChecksumAddress(\n              safeObjectAccess<string>(p, \"target\"),\n            );\n            const entrypoint = safeObjectAccess<string>(p, \"method\");\n            const contracts = safeObjectAccess<Record<string, any>>(\n              prev,\n              \"contracts\",\n            );\n            const item = {\n              name: humanizeString(entrypoint),\n              entrypoint: entrypoint,\n              description: safeObjectAccess<string>(p, \"description\"),\n            };\n\n            if (target in contracts) {\n              const methods = toArray(contracts[target].methods);\n              contracts[target] = {\n                methods: [...methods, item],\n              };\n            } else {\n              contracts[target] = {\n                methods: [item],\n              };\n            }\n          } else {\n            const messages = safeObjectAccess<any[]>(prev, \"messages\");\n            messages.push(p);\n          }\n\n          return prev;\n        },\n        { contracts: {}, messages: [] },\n      )\n    : policies;\n}\n\nexport function toWasmPolicies(policies: SessionPolicies): wasm.Policy[] {\n  return [\n    ...Object.entries(policies.contracts ?? {}).flatMap(\n      ([target, { methods }]) =>\n        toArray(methods).map((m) => ({\n          target,\n          method: m.entrypoint,\n        })),\n    ),\n    ...(policies.messages ?? []).map((p) => {\n      const domainHash = typedData.getStructHash(\n        p.types,\n        \"StarknetDomain\",\n        p.domain,\n        TypedDataRevision.ACTIVE,\n      );\n      const typeHash = typedData.getTypeHash(\n        p.types,\n        p.primaryType,\n        TypedDataRevision.ACTIVE,\n      );\n\n      return {\n        scope_hash: hash.computePoseidonHash(domainHash, typeHash),\n      };\n    }),\n  ];\n}\n\nexport function toArray<T>(val: T | T[]): T[] {\n  return Array.isArray(val) ? val : [val];\n}\n\nexport function humanizeString(str: string): string {\n  return (\n    str\n      // Convert from camelCase or snake_case\n      .replace(/([a-z])([A-Z])/g, \"$1 $2\") // camelCase to spaces\n      .replace(/_/g, \" \") // snake_case to spaces\n      .toLowerCase()\n      // Capitalize first letter\n      .replace(/^\\w/, (c) => c.toUpperCase())\n  );\n}\n","export class NotReadyToConnect extends Error {\n  constructor() {\n    super(\"Not ready to connect\");\n\n    Object.setPrototypeOf(this, NotReadyToConnect.prototype);\n  }\n}\n","import {\n  constants,\n  BigNumberish,\n  Call,\n  Abi,\n  InvocationsDetails,\n} from \"starknet\";\nimport {\n  AddInvokeTransactionResult,\n  Signature,\n  TypedData,\n} from \"@starknet-io/types-js\";\nimport { KeychainIFrame, ProfileIFrame } from \"./iframe\";\nimport {\n  ColorMode,\n  Policies,\n  Policy,\n  SessionPolicies,\n} from \"@cartridge/presets\";\n\nexport type Session = {\n  chainId: constants.StarknetChainId;\n  policies: Policy[];\n  maxFee: BigNumberish;\n  expiresAt: bigint;\n  credentials: {\n    authorization: string[];\n    privateKey: string;\n  };\n};\n\nexport enum ResponseCodes {\n  SUCCESS = \"SUCCESS\",\n  NOT_CONNECTED = \"NOT_CONNECTED\",\n  ERROR = \"ERROR\",\n  CANCELED = \"CANCELED\",\n  USER_INTERACTION_REQUIRED = \"USER_INTERACTION_REQUIRED\",\n}\n\nexport type ConnectError = {\n  code: ResponseCodes;\n  message: string;\n  error?: ControllerError;\n};\n\nexport type ControllerError = {\n  code: Number;\n  message: string;\n  data?: any;\n};\n\nexport type ConnectReply = {\n  code: ResponseCodes.SUCCESS;\n  address: string;\n  policies?: SessionPolicies;\n};\n\nexport type ExecuteReply =\n  | (AddInvokeTransactionResult & {\n      code: ResponseCodes.SUCCESS;\n    })\n  | {\n      code: ResponseCodes.USER_INTERACTION_REQUIRED;\n    };\n\nexport type ProbeReply = {\n  code: ResponseCodes.SUCCESS;\n  address: string;\n};\n\nexport type DeployReply = {\n  code: ResponseCodes.SUCCESS;\n  transaction_hash: string;\n};\n\nexport type IFrames = {\n  keychain: KeychainIFrame;\n  profile?: ProfileIFrame;\n};\n\nexport interface LookupRequest {\n  usernames?: string[];\n  addresses?: string[];\n}\n\nexport interface LookupResult {\n  username: string;\n  addresses: string[];\n}\n\nexport interface LookupResponse {\n  results: LookupResult[];\n}\n\ntype ContractAddress = string;\ntype CartridgeID = string;\nexport type ControllerAccounts = Record<ContractAddress, CartridgeID>;\n\nexport interface Keychain {\n  probe(rpcUrl: string): Promise<ProbeReply | ConnectError>;\n  connect(\n    policies: Policies,\n    rpcUrl: string,\n  ): Promise<ConnectReply | ConnectError>;\n  disconnect(): void;\n\n  reset(): void;\n  revoke(origin: string): void;\n\n  deploy(): Promise<DeployReply | ConnectError>;\n  execute(\n    calls: Call | Call[],\n    abis?: Abi[],\n    transactionsDetail?: InvocationsDetails,\n    sync?: boolean,\n    paymaster?: any,\n    error?: ControllerError,\n  ): Promise<ExecuteReply | ConnectError>;\n  signMessage(\n    typedData: TypedData,\n    account: string,\n    async?: boolean,\n  ): Promise<Signature | ConnectError>;\n  logout(): Promise<void>;\n  openSettings(): Promise<void | ConnectError>;\n  session(): Promise<Session>;\n  sessions(): Promise<{\n    [key: string]: Session;\n  }>;\n  delegateAccount(): string;\n  username(): string;\n  fetchControllers(contractAddresses: string[]): Promise<ControllerAccounts>;\n  openPurchaseCredits(): void;\n  openExecute(): void;\n}\nexport interface Profile {\n  navigate(path: string): void;\n}\n\nexport interface Modal {\n  open: () => void;\n  close: () => void;\n}\n\n/**\n * Options for configuring the controller\n */\nexport type ControllerOptions = ProviderOptions &\n  KeychainOptions &\n  ProfileOptions;\n\nexport type IFrameOptions = {\n  /** The ID of the starter pack to use */\n  starterPackId?: string;\n  /** The theme to use */\n  theme?: string;\n  /** The preset to use */\n  preset?: string;\n  /** The color mode to use */\n  colorMode?: ColorMode;\n};\n\nexport type ProviderOptions = {\n  /** The URL of the RPC */\n  rpc: string;\n};\n\nexport type KeychainOptions = IFrameOptions & {\n  policies?: Policies;\n  /** The URL of keychain */\n  url?: string;\n  /** The origin of keychain */\n  origin?: string;\n  /** Propagate transaction errors back to caller instead of showing modal */\n  propagateSessionErrors?: boolean;\n};\n\nexport type ProfileOptions = IFrameOptions & {\n  /** The URL of profile. Mainly for internal development purpose */\n  profileUrl?: string;\n  /** The project name of Slot instance. */\n  slot?: string;\n  /** The namespace to use to fetch trophies data from indexer. Will be mandatory once profile page is in production */\n  namespace?: string;\n  /** The tokens to be listed on Inventory modal */\n  tokens?: Tokens;\n};\n\nexport type ProfileContextTypeVariant =\n  | \"inventory\"\n  | \"trophies\"\n  | \"achievements\"\n  | \"activity\";\n\nexport type Prefund = { address: string; min: string };\n\nexport type Tokens = {\n  erc20?: string[];\n};\n"],"mappings":";AACA,SAAS,+BAA+B;AACxC,SAAuC,qBAAqB;;;ACF5D;AAAA,EACE;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AA4BA,SAAS,eAAe,OAAsB;AACnD,SAAO,QAAQ,KAAK,EAAE,IAAI,CAAC,SAAS;AAClC,WAAO;AAAA,MACL,YAAY,KAAK;AAAA,MACjB,iBAAiB,kBAAkB,KAAK,eAAe;AAAA,MACvD,UAAU,SAAS,MAAM,KAAK,QAAQ;AAAA,IACxC;AAAA,EACF,CAAC;AACH;AAwEO,SAAS,QAAW,KAAmB;AAC5C,SAAO,MAAM,QAAQ,GAAG,IAAI,MAAM,CAAC,GAAG;AACxC;;;ACtHO,IAAM,oBAAN,MAAM,2BAA0B,MAAM;AAAA,EAC3C,cAAc;AACZ,UAAM,sBAAsB;AAE5B,WAAO,eAAe,MAAM,mBAAkB,SAAS;AAAA,EACzD;AACF;;;ACyBO,IAAK,gBAAL,kBAAKA,mBAAL;AACL,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,mBAAgB;AAChB,EAAAA,eAAA,WAAQ;AACR,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,+BAA4B;AALlB,SAAAA;AAAA,GAAA;;;AHrBZ,IAAqB,iBAArB,cAA4C,cAAc;AAAA,EAGxD,YACE,UACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GASA;AACA,UAAM,EAAE,SAAS,OAAO,GAAG,QAAQ;AAEnC,SAAK,aAAa,wBAAwB;AAAA,MACxC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAM,QAAQ,OAAuD;AACnE,WAAO,KAAK,WAAW,QAAQ,eAAe,KAAK,CAAC;AAAA,EACtD;AACF;","names":["ResponseCodes"]}