// src/utils.ts
import {
  addAddressPadding,
  CallData,
  getChecksumAddress,
  hash,
  typedData,
  TypedDataRevision
} from "starknet";
var ALLOWED_PROPERTIES = /* @__PURE__ */ new Set([
  "contracts",
  "messages",
  "target",
  "method",
  "name",
  "description",
  "types",
  "domain",
  "primaryType"
]);
function validatePropertyName(prop) {
  if (!ALLOWED_PROPERTIES.has(prop)) {
    throw new Error(`Invalid property name: ${prop}`);
  }
}
function safeObjectAccess(obj, prop) {
  validatePropertyName(prop);
  return obj[prop];
}
function normalizeCalls(calls) {
  return toArray(calls).map((call) => {
    return {
      entrypoint: call.entrypoint,
      contractAddress: addAddressPadding(call.contractAddress),
      calldata: CallData.toHex(call.calldata)
    };
  });
}
function toSessionPolicies(policies) {
  return Array.isArray(policies) ? policies.reduce(
    (prev, p) => {
      if (safeObjectAccess(p, "target")) {
        const target = getChecksumAddress(
          safeObjectAccess(p, "target")
        );
        const entrypoint = safeObjectAccess(p, "method");
        const contracts = safeObjectAccess(
          prev,
          "contracts"
        );
        const item = {
          name: humanizeString(entrypoint),
          entrypoint,
          description: safeObjectAccess(p, "description")
        };
        if (target in contracts) {
          const methods = toArray(contracts[target].methods);
          contracts[target] = {
            methods: [...methods, item]
          };
        } else {
          contracts[target] = {
            methods: [item]
          };
        }
      } else {
        const messages = safeObjectAccess(prev, "messages");
        messages.push(p);
      }
      return prev;
    },
    { contracts: {}, messages: [] }
  ) : policies;
}
function toWasmPolicies(policies) {
  return [
    ...Object.entries(policies.contracts ?? {}).flatMap(
      ([target, { methods }]) => toArray(methods).map((m) => ({
        target,
        method: m.entrypoint
      }))
    ),
    ...(policies.messages ?? []).map((p) => {
      const domainHash = typedData.getStructHash(
        p.types,
        "StarknetDomain",
        p.domain,
        TypedDataRevision.ACTIVE
      );
      const typeHash = typedData.getTypeHash(
        p.types,
        p.primaryType,
        TypedDataRevision.ACTIVE
      );
      return {
        scope_hash: hash.computePoseidonHash(domainHash, typeHash)
      };
    })
  ];
}
function toArray(val) {
  return Array.isArray(val) ? val : [val];
}
function humanizeString(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/_/g, " ").toLowerCase().replace(/^\w/, (c) => c.toUpperCase());
}
export {
  humanizeString,
  normalizeCalls,
  toArray,
  toSessionPolicies,
  toWasmPolicies
};
//# sourceMappingURL=utils.js.map