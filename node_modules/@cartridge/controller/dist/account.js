// src/account.ts
import {
  WalletAccount
} from "starknet";

// src/utils.ts
import {
  addAddressPadding,
  CallData,
  getChecksumAddress,
  hash,
  typedData,
  TypedDataRevision
} from "starknet";
function toArray(val) {
  return Array.isArray(val) ? val : [val];
}

// src/account.ts
var ControllerAccount = class extends WalletAccount {
  constructor(provider, address, keychain, options, modal) {
    super({ nodeUrl: provider.rpc.toString() }, provider);
    this.address = address;
    this.keychain = keychain;
    this.options = options;
    this.modal = modal;
  }
  /**
   * Invoke execute function in account contract
   *
   * @param calls the invocation object or an array of them, containing:
   * - contractAddress - the address of the contract
   * - entrypoint - the entrypoint of the contract
   * - calldata - (defaults to []) the calldata
   * - signature - (defaults to []) the signature
   * @param abis (optional) the abi of the contract for better displaying
   *
   * @returns response from addTransaction
   */
  async execute(calls) {
    calls = toArray(calls);
    return new Promise(async (resolve, reject) => {
      const sessionExecute = await this.keychain.execute(
        calls,
        void 0,
        void 0,
        false
      );
      if (sessionExecute.code === "SUCCESS" /* SUCCESS */) {
        resolve(sessionExecute);
        return;
      }
      if (this.options?.propagateSessionErrors) {
        reject(sessionExecute.error);
        return;
      }
      this.modal.open();
      const manualExecute = await this.keychain.execute(
        calls,
        void 0,
        void 0,
        true,
        sessionExecute.error
      );
      if (manualExecute.code === "SUCCESS" /* SUCCESS */) {
        resolve(manualExecute);
        this.modal.close();
        return;
      }
      reject(manualExecute.error);
      return;
    });
  }
  /**
   * Sign an JSON object for off-chain usage with the starknet private key and return the signature
   * This adds a message prefix so it cant be interchanged with transactions
   *
   * @param json - JSON object to be signed
   * @returns the signature of the JSON object
   * @throws {Error} if the JSON object is not a valid JSON
   */
  async signMessage(typedData2) {
    return new Promise(async (resolve, reject) => {
      const sessionSign = await this.keychain.signMessage(typedData2, "", true);
      if (!("code" in sessionSign)) {
        resolve(sessionSign);
        return;
      }
      this.modal.open();
      const manualSign = await this.keychain.signMessage(typedData2, "", false);
      if (!("code" in manualSign)) {
        resolve(manualSign);
      } else {
        reject(manualSign.error);
      }
      this.modal.close();
    });
  }
};
var account_default = ControllerAccount;
export {
  account_default as default
};
//# sourceMappingURL=account.js.map